module;

#include "Angaraka/Base.hpp"

export module Angaraka.Core.Resources;

struct TexMetadata;

import Angaraka.Core.Events;

namespace Angaraka::Core {

    // Simple struct to hold raw image data on the CPU side
    // before it's uploaded to the GPU.
    export struct ImageData
    {
        std::unique_ptr<uint8_t[]> Pixels; // Raw pixel data
        size_t Width = 0;
        size_t Height = 0;
        size_t RowPitch = 0;    // Bytes per row
        size_t SlicePitch = 0;  // Bytes per slice (for 3D textures, etc.)
        int Format = 0;         // DXGI_FORMAT as int, to avoid D3D12 headers here
        // Add more metadata if needed (e.g., mip levels, array size)
    };

    /**
     * @brief Base class for all managed resources in the engine.
     *
     * This abstract class provides common interface for all assets
     * that are managed by the ResourceManager.
     */
    export class Resource {
    public:
        /**
         * @brief Virtual destructor to ensure proper cleanup of derived classes.
         */
        virtual ~Resource() = default;

        /**
         * @brief Get the unique identifier (e.g., file path) of the resource.
         * @return A const reference to the resource's identifier string.
         */
        const std::string& GetId() const { return m_id; }

        /**
         * @brief Get the type ID of the resource.
         * @return A static type ID, typically generated by a macro.
         */
        virtual size_t GetTypeId() const = 0;

        /**
         * @brief Pure virtual method for loading the resource data.
         *
         * Derived classes must implement this to perform their specific loading logic.
         * This method should handle parsing file formats and preparing data.
         * @param filePath The path from which to load the resource.
         * @return True if loading was successful, false otherwise.
         */
        virtual bool Load(const std::string& filePath) = 0;

        /**
         * @brief Pure virtual method for unloading/releasing the resource data.
         *
         * Derived classes must implement this to free their allocated memory
         * or release GPU resources.
         */
        virtual void Unload() = 0;

        // Optionally, add a virtual method to prepare for GPU upload,
        // or ensure GPU-specific setup happens in a specialized system.

    protected:
        // Protected constructor to ensure Resource is only created by derived classes.
        explicit Resource(const std::string& id) : m_id(id) {}

    private:
        std::string m_id; // Unique identifier for this resource (e.g., its file path)

    };

    /**
     * @brief Singleton-like manager for all engine resources.
     *
     * Handles loading, caching, and managing the lifetime of various asset types.
     */
    export class ResourceManager
    {
    public:
        explicit ResourceManager(Angaraka::Events::EventManager& eventBus);
        ~ResourceManager();

        // Delete copy constructor and assignment operator for singleton-like behavior
        ResourceManager(const ResourceManager&) = delete;
        ResourceManager& operator=(const ResourceManager&) = delete;


        /**
         * @brief Get a resource by its identifier.
         *
         * If the resource is already loaded and cached, it's returned directly.
         * Otherwise, it attempts to load the resource.
         * @tparam T The concrete type of the resource (must derive from Resource).
         * @param id The unique identifier/path of the resource.
         * @return A shared_ptr to the requested resource, or nullptr if loading fails.
         */
        template<typename T>
        inline std::shared_ptr<T> GetResource(const std::string& id) {
            std::lock_guard<std::mutex> lock(m_resourcesMutex);

            // 1. Check if resource is already loaded
            auto it = m_loadedResources.find(id);
            if (it != m_loadedResources.end()) {
                // Check if the type matches. Dynamic cast for safety/correctness.
                std::shared_ptr<T> resource = std::dynamic_pointer_cast<T>(it->second);
                if (resource) {
                    AGK_INFO("ResourceManager: Found cached resource '{0}' of type {1}.", id, typeid(T).name());
                    return resource;
                }
                else {
                    AGK_ERROR("ResourceManager: Cached resource '{0}' found but type mismatch! Requested {1}, got {2}.", id, typeid(T).name(), typeid(*it->second).name());
                    // In a real engine, you might throw an exception or return nullptr
                    return nullptr;
                }
            }

            // 2. Resource not found, attempt to load it
            AGK_INFO("ResourceManager: Resource '{0}' not found in cache. Attempting to load...", id);
            std::shared_ptr<T> newResource = std::make_shared<T>(id); // Resource constructor takes ID

            // Attempt to load the resource
            if (newResource->Load(id)) { // Pass id as filePath for now
                m_loadedResources[id] = newResource; // Add to cache
                AGK_INFO("ResourceManager: Successfully loaded and cached resource '{0}'.", id);
                return newResource;
            }
            else {
                AGK_ERROR("ResourceManager: Failed to load resource '{0}'.", id);
                return nullptr; // Loading failed
            }
        }

        /**
         * @brief Unload a specific resource from memory.
         * @param id The unique identifier/path of the resource to unload.
         */
        void UnloadResource(const std::string& id);

        /**
         * @brief Unload all currently loaded resources.
         */
        void UnloadAllResources();

    private:
        // Use a map to store currently loaded resources, keyed by their ID.
        // Use shared_ptr to manage lifetime based on references.
        std::unordered_map<std::string, std::shared_ptr<Resource>> m_loadedResources;
        mutable std::mutex m_resourcesMutex; // Protect access to m_loadedResources

        Angaraka::Events::EventManager& m_eventBus;

        // Private helper to load a resource given its type ID and file path
        std::shared_ptr<Resource> LoadResourceInternal(size_t typeId, const std::string& filePath);

    };
}